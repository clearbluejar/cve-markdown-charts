from tabnanny import verbose
from urllib import response
import requests
from datetime import datetime
import json
from bs4 import BeautifulSoup
import os
from mdutils.tools.Table import Table
from html import escape
import argparse
import dateparser


msrc_api_url = "https://api.msrc.microsoft.com/"
cve_url = "https://cve.mitre.org/cgi-bin/"
# https://nvd.nist.gov/vuln/data-feeds#JSON_FEED
nist_api_url = "https://services.nvd.nist.gov/rest/json/cves/1.0/"

def get_json_cve_list_from_keyword_ndist(keyword,start_date,end_date):
    cve_list = []
    start = dateparser.parse("66 years ago",settings={'RETURN_AS_TIMEZONE_AWARE': True})
    end = dateparser.parse("now",settings={'RETURN_AS_TIMEZONE_AWARE': True})
    
    url = "{}?keyword={}&resultsPerPage={}".format(nist_api_url, str(keyword), 2000)
    response = requests.get(url)
    print(response.request.url)
    if response.status_code == 200:
        data = json.loads(response.content)

        # create list of CVEs
        for cve in data['result']['CVE_Items']:
                # filter by date
                pubDate = dateparser.parse(cve['publishedDate'])
                if pubDate >= start and pubDate <= end:
                    cve_list.append(cve)
                else:
                    print("Skipping {} with pubDate:{}".format(cve['cve']['CVE_data_meta']['ID'],cve['publishedDate']))

    # sort list by date
    cve_list = sorted(cve_list, key=lambda x: x['publishedDate'],reverse=True)


    return json.dumps(cve_list)

""" def get_json_cve_list_from_keyword(keyword):
    cve_list = []
    url = "{}cvekey.cgi?keyword={}".format(cve_url, str(keyword))
    response = requests.get(url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, "html.parser")
        results = soup.find(id="TableWithRules")
        #print(results.prettify())
        tds = results.find_all("td")
        tds = iter(tds)
        for td in tds:
            cve_list.append({'id': td.get_text(),'description' : escape(next(tds).get_text().replace('\n',' '))})

    return json.dumps(cve_list) """

def get_json_cve_list_from_KB(kb):
    return None

def get_json_cve_list_from_researcher(researcher):
    return None

#Find the cvrf_id (in the form YYYY-Month) given the CVE of interest
def get_cvrf_id_and_date_for_cve(cve):
    # derived from https://github.com/NopSec/ThreatIntelScripts/blob/master/find_microsoft_kb_by_cve.py#L9

    cvrf_id = None
    releaseDate = None

    cache_path = '.cache'    
 
    # load cache mapping
    cve_to_cvrf_file = os.path.join(cache_path,'cve_to_cvrf.json')
    
    if not os.path.exists(cve_to_cvrf_file):
        cve_to_cvrf = {}
    else:
        with open(cve_to_cvrf_file) as f:
            cve_to_cvrf = json.load(f)

    if cve_to_cvrf.get(cve) is None:
        year = int(cve.split('-')[1])
        # MSRC CVRF is not available before 2016
        if year > 2015:
            url = "{}Updates('{}')?api-version={}".format(msrc_api_url, str(cve),   str(datetime.datetime.now().year))
            headers = {}
            response = requests.get(url, headers=headers)

            if response.status_code == 200:
                data = json.loads(response.content)
                cve_to_cvrf[cve] = data["value"][0]
                cve_to_cvrf['updated'] = datetime.datetime.now().strftime('%Y-%m-%d')
                with open(cve_to_cvrf_file, 'w') as f:
                    json.dump(cve_to_cvrf, f)
            else:
                cve_to_cvrf[cve] = {}
        else:
            cve_to_cvrf[cve] = {}
            

    cvrf_id = cve_to_cvrf[cve].get('ID')
    releaseDate = cve_to_cvrf[cve].get('InitialReleaseDate')

    with open(cve_to_cvrf_file, 'w') as f:
            json.dump(cve_to_cvrf, f)

    return cvrf_id,releaseDate


def get_all_knowledge_base_cvrf():
    cvrfs = []

    url = "{}Updates?api-version={}".format(msrc_api_url,str(datetime.datetime.now().year))
    headers = {}
    response = requests.get(url, headers=headers)

    if response.status_code == 200:
        data = json.loads(response.content)
        
        for cvrf in data['value']:
            get_knowledge_base_cvrf_json(cvrf['ID'])


    return 

def get_knowledge_base_cvrf_json(cvrf_id):
    if cvrf_id == None:
        return None
    cvrf_json = None

    cache_path = '.cache'
    if not os.path.exists(cache_path):
        os.mkdir(cache_path)

    # if file exists locally, load it
    cvrf_file = os.path.join(cache_path,cvrf_id+".json")
    if not os.path.exists(cvrf_file):
        url = "{}cvrf/{}?api-Version={}".format(msrc_api_url, cvrf_id, str(datetime.datetime.now().year))
        headers = {'Accept': 'application/json'}
        response = requests.get(url, headers = headers)
        with open(cvrf_file, 'w') as f:
            json.dump(json.loads(response.content), f)

    with open(cvrf_file) as f:
        cvrf_json = json.load(f)

    return cvrf_json

def build_markdown_table_from_cves(cves,keyword):
    print("Building table...")

    table_list = []
    table_list.extend(['CVE','Description', 'Release Date', 'KBs', 'Acknowledgments'])
    column_len = len(table_list)

    cves = json.loads(cves)
    for cve in cves:
        cve_id = cve['cve']['CVE_data_meta']['ID']
        cve_description = cve['cve']['description']['description_data'][0]['value']
        print(cve_id)
        cvrf_id,release_date = get_cvrf_id_and_date_for_cve(cve_id)
        cvrf_json = get_knowledge_base_cvrf_json(cvrf_id)
        
        if cvrf_json:
            release_date = '[{}](https://msrc.microsoft.com/update-guide/en-US/vulnerability/{})'.format(release_date,cve_id)
            #description = [vuln['Title']['Value'] for vuln in cvrf_json["Vulnerability"] if vuln["CVE"] == cve_id]
            kbs = {'[KB{}]({})-{}'.format(kb['Description']['Value'],kb['URL'],kb.get('FixedBuild')) for vuln in cvrf_json["Vulnerability"] if vuln["CVE"] == cve_id for kb in vuln["Remediations"] if (str(kb['Description']['Value']).isnumeric() and 'FixedBuild' in kb)  }
            kbs = sorted(['[{}]({}) - [KB{}]({})'.format(kb.get('FixedBuild'),'https://support.microsoft.com/help/{}'.format(kb['Description']['Value']),kb['Description']['Value'],kb['URL']) for vuln in cvrf_json["Vulnerability"] if vuln["CVE"] == cve_id for kb in vuln["Remediations"] if (str(kb['Description']['Value']).isnumeric() and 'catalog' in kb['URL'] )])
            acks = {'{}'.format(ack['Name'][0].get('Value')) for vuln in cvrf_json["Vulnerability"] if vuln["CVE"] == cve_id for ack in vuln["Acknowledgments"] }
        else:
            kbs = ''
            builds = ''
            acks = ''
                
        cve_link = '[{}](https://cve.mitre.org/cgi-bin/cvename.cgi?name={})'.format(cve_id,cve_id)

        table_list.extend([cve_link,cve_description,release_date,'<details>'+'<br>'.join(kbs)+'</details>', '<br>'.join(acks).replace('\n',' ')])
        
    cve_table = Table().create_table(columns=column_len, rows=len(cves)+1, text=table_list, text_align='center')

    #write results to disk
    table_path = keyword.replace(' ','-') + '-table.md'
    with open(table_path, 'w') as f:
        f.write(cve_table)

    print(cve_table)
    print('\nCVE table available: ' + table_path + '\n')

def build_markdown_gantt_from_cves_by_release_date(cves,keyword='CVE Markdown Gantt'):
    gantt_template = '''
```mermaid
gantt

title {keyword}
dateFormat YYYY-MM-DD
axisFormat %Y-%m

section CVE Release Dates
{rows}

```
'''
    
    print("Building gantt chart...")

    cves = json.loads(cves)
    rows = []

    sections = {}
    for num,cve in enumerate(cves):

        cve_id = cve['cve']['CVE_data_meta']['ID']
        release_date = datetime.strptime(cve['publishedDate'],'%Y-%m-%dT%H:%MZ')        
        fake_cvrf_id = release_date.strftime("%Y-%b")
        release_date = release_date.strftime("%Y-%m-%d")

        row = '{} :cve{}, {}, 30d'.format(cve_id,num,release_date)
        sections.setdefault(fake_cvrf_id,[]).append(row)

    sorted_sections = sorted(sections.items(), key = lambda x:datetime.strptime(x[0], '%Y-%b'), reverse=True)    

    for section in sorted_sections:
        rows.append('section {}'.format(section[0]))
        rows.append('\n'.join(section[1]))

    gantt_path = keyword.replace(' ','-') + '-gantt.md'
    gantt = gantt_template.format(keyword=keyword,rows='\n'.join(rows))
    with open(gantt_path, 'w') as f:
        f.write(gantt)
    
    print(gantt)
    print('Gantt chart available: ' + gantt_path)
    

def build_markdown_researcher_vanity_chart(cves,researcher):
    return None

def build_markdown_pie_from_cves_by_cwe(cves,keyword):
    pie_template = '''
```mermaid
pie showData
    title {keyword}
{rows}

```
'''
    
    print("Building gantt chart...")

    cves = json.loads(cves)
    rows = []

    cwes = {}
    for num,cve in enumerate(cves):        
        cve_id = cve['cve']['CVE_data_meta']['ID']
        problems = cve['cve']['problemtype']['problemtype_data']
        
        for problem in problems:
            cwe = problem['description'][0]['value']
            cwes.setdefault(cwe,[]).append(cve_id)

    print(cwes)

    for cwe in cwes:
        rows.append('    "{}" : {}'.format(cwe,len(cwes[cwe])))
        

    pie_path = keyword.replace(' ','-') + '-pie.md'
    pie = pie_template.format(keyword=keyword,rows='\n'.join(rows))
    with open(pie_path, 'w') as f:
        f.write(pie)
    
    print(pie)
    print('Pie chart available: ' + pie_path)    

    return None

parser = argparse.ArgumentParser(description='Generate CVE Markdown Charts')
parser.add_argument('keyword',  nargs='+', help='The CVE keyword to chart')

args = parser.parse_args()


keyword = ' '.join(args.keyword)


# Get List of CVEs
#cve_json = get_json_cve_list_from_keyword(args.keyword)
cve_json = get_json_cve_list_from_keyword_ndist(keyword,None,None)

cves = json.loads(cve_json)
print(json.dumps(cve_json, indent=4, sort_keys=True))


build_markdown_table_from_cves(cve_json,keyword)
build_markdown_gantt_from_cves_by_release_date(cve_json,keyword)
build_markdown_pie_from_cves_by_cwe(cve_json,keyword)
